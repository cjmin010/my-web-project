"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./data/users.ts":
/*!***********************!*\
  !*** ./data/users.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUser: function() { return /* binding */ addUser; },\n/* harmony export */   deleteUser: function() { return /* binding */ deleteUser; },\n/* harmony export */   getCurrentUser: function() { return /* binding */ getCurrentUser; },\n/* harmony export */   getUsers: function() { return /* binding */ getUsers; },\n/* harmony export */   loginUser: function() { return /* binding */ loginUser; },\n/* harmony export */   logoutUser: function() { return /* binding */ logoutUser; },\n/* harmony export */   saveUsers: function() { return /* binding */ saveUsers; },\n/* harmony export */   setCurrentUser: function() { return /* binding */ setCurrentUser; },\n/* harmony export */   updateUser: function() { return /* binding */ updateUser; },\n/* harmony export */   validateEmail: function() { return /* binding */ validateEmail; },\n/* harmony export */   validatePassword: function() { return /* binding */ validatePassword; },\n/* harmony export */   validatePhone: function() { return /* binding */ validatePhone; },\n/* harmony export */   validateUserId: function() { return /* binding */ validateUserId; }\n/* harmony export */ });\n/* harmony import */ var _lib_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/crypto */ \"(app-pages-browser)/./lib/crypto.ts\");\n/* harmony import */ var _lib_security__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/security */ \"(app-pages-browser)/./lib/security.ts\");\n\n\n// 초기 사용자 데이터 (비밀번호는 앱 시작 시 해싱됩니다)\nconst initialUsersData = [\n    {\n        id: \"admin\",\n        password: \"admin\",\n        name: \"관리자\",\n        email: \"admin@example.com\",\n        phone: \"010-0000-0000\",\n        address: \"서울특별시 강남구\",\n        addressDetail: \"테헤란로 123\",\n        zipCode: \"06123\",\n        role: \"admin\",\n        createdAt: \"2024-01-01\",\n        isActive: true,\n        isRejected: false\n    },\n    {\n        id: \"aaa\",\n        password: \"aaa\",\n        name: \"김철수\",\n        email: \"aaa@example.com\",\n        phone: \"010-1111-1111\",\n        address: \"서울특별시 서초구\",\n        addressDetail: \"강남대로 456\",\n        zipCode: \"06611\",\n        role: \"user\",\n        createdAt: \"2024-01-15\",\n        isActive: true\n    },\n    {\n        id: \"bbb\",\n        password: \"bbb\",\n        name: \"이영희\",\n        email: \"bbb@example.com\",\n        phone: \"010-2222-2222\",\n        address: \"서울특별시 마포구\",\n        addressDetail: \"홍대로 789\",\n        zipCode: \"04039\",\n        role: \"user\",\n        createdAt: \"2024-01-20\",\n        isActive: true\n    },\n    {\n        id: \"ccc\",\n        password: \"ccc\",\n        name: \"씨씨씨\",\n        email: \"ccc@example.com\",\n        phone: \"010-3333-3333\",\n        address: \"주소 미입력\",\n        role: \"user\",\n        createdAt: \"2024-05-25\",\n        isActive: false\n    }\n];\n// 로컬 스토리지 키\nconst USERS_STORAGE_KEY = \"mini_store_users\";\nconst CURRENT_USER_KEY = \"mini_store_current_user\";\nconst USERS_VERSION_KEY = \"mini_store_users_version\";\nconst CURRENT_VERSION = \"1.10\"; // 데이터 구조 변경 시 이 버전을 올립니다.\n// 메모리 내 사용자 캐시\nlet usersCache = null;\n// 초기 사용자 데이터를 동기적으로 생성 (서버 사이드 및 초기 클라이언트 렌더링용)\n// 비밀번호 해싱과 같은 비동기 작업은 포함하지 않음\nconst getInitialUsersSynchronously = ()=>{\n    return initialUsersData.map((user)=>({\n            id: user.id,\n            password: user.password || \"\",\n            name: user.name || \"N/A\",\n            email: user.email || \"N/A\",\n            phone: user.phone || \"N/A\",\n            address: user.address || \"N/A\",\n            addressDetail: user.addressDetail || \"\",\n            zipCode: user.zipCode || \"\",\n            role: user.role,\n            createdAt: user.createdAt || new Date().toISOString().split(\"T\")[0],\n            isActive: user.isActive === undefined ? true : user.isActive,\n            isRejected: user.isRejected === undefined ? false : user.isRejected,\n            failedLoginAttempts: 0,\n            isLocked: false,\n            mustChangePassword: false\n        }));\n};\n// 사용자 데이터 초기화 함수 (클라이언트 사이드 비동기)\nconst initializeUsers = async ()=>{\n    const hashedUsers = await Promise.all(initialUsersData.map(async (user)=>{\n        const hashedPassword = await (0,_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.hashPassword)(user.password || \"\");\n        return {\n            id: user.id,\n            password: hashedPassword,\n            name: user.name || \"N/A\",\n            email: user.email || \"N/A\",\n            phone: user.phone || \"N/A\",\n            address: user.address || \"N/A\",\n            addressDetail: user.addressDetail || \"\",\n            zipCode: user.zipCode || \"\",\n            role: user.role,\n            createdAt: user.createdAt || new Date().toISOString().split(\"T\")[0],\n            isActive: user.isActive === undefined ? true : user.isActive,\n            isRejected: user.isRejected === undefined ? false : user.isRejected,\n            failedLoginAttempts: 0,\n            isLocked: false,\n            mustChangePassword: false\n        };\n    }));\n    saveUsers(hashedUsers);\n    return hashedUsers;\n};\n// 사용자 데이터 관리 함수들\nconst getUsers = ()=>{\n    // 서버 사이드 (API 라우트 등)\n    if (false) {}\n    // 클라이언트 사이드\n    if (usersCache) {\n        return usersCache;\n    }\n    const storedVersion = localStorage.getItem(USERS_VERSION_KEY);\n    const storedUsers = localStorage.getItem(USERS_STORAGE_KEY);\n    if (!storedUsers || storedVersion !== CURRENT_VERSION) {\n        console.log(\"Initializing or updating user data in localStorage.\");\n        const initialUsers = getInitialUsersSynchronously();\n        usersCache = initialUsers; // 먼저 동기 데이터로 캐시 채우기\n        // 백그라운드에서 비동기 해싱 및 저장\n        initializeUsers().then((hashedUsers)=>{\n            usersCache = hashedUsers; // 해싱된 데이터로 캐시 업데이트\n        });\n        return initialUsers; // 동기적으로 초기 데이터 우선 반환\n    }\n    try {\n        const parsedUsers = JSON.parse(storedUsers);\n        usersCache = parsedUsers;\n        return parsedUsers;\n    } catch (error) {\n        console.error(\"로컬 스토리지에서 사용자 정보를 파싱하는 데 실패했습니다.\", error);\n        localStorage.removeItem(USERS_STORAGE_KEY);\n        // 비동기 초기화 실행\n        initializeUsers().then((hashedUsers)=>{\n            usersCache = hashedUsers;\n        });\n        // 일단 빈 배열 반환, UI는 Context에 따라 리렌더링 될 것\n        return [];\n    }\n};\nconst saveUsers = (users)=>{\n    // 메모리 캐시 업데이트\n    usersCache = users;\n    if (false) {}\n    localStorage.setItem(USERS_STORAGE_KEY, JSON.stringify(users));\n    localStorage.setItem(USERS_VERSION_KEY, CURRENT_VERSION);\n};\nconst addUser = async (userData)=>{\n    const users = getUsers();\n    if (users.some((u)=>u.id === userData.id)) {\n        throw new Error(\"이미 존재하는 ID입니다.\");\n    }\n    const hashedPassword = await (0,_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.hashPassword)(userData.password);\n    const newUser = {\n        ...userData,\n        password: hashedPassword,\n        createdAt: new Date().toISOString().split(\"T\")[0],\n        failedLoginAttempts: 0,\n        isLocked: false,\n        mustChangePassword: false\n    };\n    const updatedUsers = [\n        ...users,\n        newUser\n    ];\n    saveUsers(updatedUsers);\n    return newUser;\n};\nconst updateUser = async (id, updates)=>{\n    let users = getUsers();\n    const userIndex = users.findIndex((u)=>u.id === id);\n    if (userIndex === -1) {\n        throw new Error(\"사용자를 찾을 수 없습니다.\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        ...updates\n    };\n    if (updates.password && updates.password !== users[userIndex].password) {\n        updatedUser.password = await (0,_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.hashPassword)(updates.password);\n    }\n    const updatedUsers = [\n        ...users\n    ];\n    updatedUsers[userIndex] = updatedUser;\n    saveUsers(updatedUsers);\n    return updatedUser;\n};\nconst deleteUser = (id)=>{\n    const users = getUsers();\n    const filteredUsers = users.filter((u)=>u.id !== id);\n    saveUsers(filteredUsers);\n};\nconst loginUser = async (id, password)=>{\n    const users = getUsers();\n    const user = users.find((u)=>u.id === id);\n    if (!user) {\n        return {\n            success: false,\n            message: \"ID 또는 비밀번호가 올바르지 않습니다.\"\n        };\n    }\n    if (!user.isActive) {\n        return {\n            success: false,\n            message: \"비활성화된 계정입니다.\"\n        };\n    }\n    if (user.isLocked) {\n        return {\n            success: false,\n            message: \"계정이 잠겼습니다. 관리자에게 문의하세요.\"\n        };\n    }\n    const settings = (0,_lib_security__WEBPACK_IMPORTED_MODULE_1__.getSecuritySettings)();\n    const isValidPassword = await (0,_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.verifyPassword)(password, user.password);\n    if (isValidPassword) {\n        const updatedUser = {\n            ...user,\n            failedLoginAttempts: 0\n        };\n        await updateUser(id, {\n            failedLoginAttempts: 0\n        });\n        return {\n            success: true,\n            message: \"로그인 성공\",\n            user: updatedUser\n        };\n    } else {\n        const newAttempts = user.failedLoginAttempts + 1;\n        let message = \"ID 또는 비밀번호가 올바르지 않습니다. (남은 시도: \".concat(settings.maxLoginAttempts - newAttempts, \"회)\");\n        let isLocked = user.isLocked;\n        if (newAttempts >= settings.maxLoginAttempts) {\n            isLocked = true;\n            message = \"로그인 시도 횟수를 초과하여 계정이 잠겼습니다. (\".concat(settings.maxLoginAttempts, \"회 초과)\");\n        }\n        await updateUser(id, {\n            failedLoginAttempts: newAttempts,\n            isLocked\n        });\n        return {\n            success: false,\n            message: message\n        };\n    }\n};\nconst getCurrentUser = ()=>{\n    if (false) {}\n    const stored = localStorage.getItem(CURRENT_USER_KEY);\n    try {\n        return stored ? JSON.parse(stored) : null;\n    } catch (e) {\n        return null;\n    }\n};\nconst setCurrentUser = (user)=>{\n    if (false) {}\n    if (user) {\n        localStorage.setItem(CURRENT_USER_KEY, JSON.stringify(user));\n    } else {\n        localStorage.removeItem(CURRENT_USER_KEY);\n    }\n};\nconst logoutUser = ()=>{\n    setCurrentUser(null);\n};\nconst validateUserId = (id)=>{\n    if (id.length < 4) return \"ID는 4자 이상이어야 합니다.\";\n    if (id.length > 20) return \"ID는 20자 이하여야 합니다.\";\n    if (!/^[a-zA-Z0-9_]+$/.test(id)) return \"ID는 영문, 숫자, 언더스코어만 사용 가능합니다.\";\n    return null;\n};\nconst validatePassword = (password)=>{\n    if (password.length < 4) return \"비밀번호는 4자 이상이어야 합니다.\";\n    // 정규식: 최소 8자, 하나 이상의 문자, 하나의 숫자 및 하나의 특수 문자\n    // if (!/^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,}$/.test(password)) {\n    //     return '비밀번호는 최소 8자, 하나 이상의 문자, 숫자, 특수문자를 포함해야 합니다.';\n    // }\n    return null;\n};\nconst validateEmail = (email)=>{\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) return \"유효하지 않은 이메일 주소입니다.\";\n    return null;\n};\nconst validatePhone = (phone)=>{\n    if (!/^\\d{3}-\\d{3,4}-\\d{4}$/.test(phone)) return \"유효하지 않은 전화번호 형식입니다. (예: 010-1234-5678)\";\n    return null;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxNQUFNLEdBQUcsR0FBRyxPQUFPO0lBQ2hDLDRDQUE0QztJQUM1QywwRkFBMEY7SUFDMUYsNERBQTREO0lBQzVELElBQUk7SUFDSixPQUFPO0FBQ1gsRUFBRTtBQUVLLE1BQU1HLGdCQUFnQixDQUFDOUU7SUFDMUIsSUFBSSxDQUFDLDZCQUE2QjRFLElBQUksQ0FBQzVFLFFBQVEsT0FBTztJQUN0RCxPQUFPO0FBQ1gsRUFBRTtBQUVLLE1BQU0rRSxnQkFBZ0IsQ0FBQzlFO0lBQzFCLElBQUksQ0FBQyx3QkFBd0IyRSxJQUFJLENBQUMzRSxRQUFRLE9BQU87SUFDakQsT0FBTztBQUNYLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vZGF0YS91c2Vycy50cz83MDVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2hQYXNzd29yZCwgdmVyaWZ5UGFzc3dvcmQgfSBmcm9tICdAL2xpYi9jcnlwdG8nO1xyXG5pbXBvcnQgeyBnZXRTZWN1cml0eVNldHRpbmdzIH0gZnJvbSAnQC9saWIvc2VjdXJpdHknO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBwYXNzd29yZDogc3RyaW5nOyAvLyBTSEEyNTYg7ZW07Iuc65CcIOu5hOuwgOuyiO2YuFxyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZW1haWw6IHN0cmluZztcclxuICAgIHBob25lOiBzdHJpbmc7XHJcbiAgICBhZGRyZXNzOiBzdHJpbmc7XHJcbiAgICBhZGRyZXNzRGV0YWlsOiBzdHJpbmc7XHJcbiAgICB6aXBDb2RlOiBzdHJpbmc7XHJcbiAgICByb2xlOiAndXNlcicgfCAnYWRtaW4nO1xyXG4gICAgY3JlYXRlZEF0OiBzdHJpbmc7XHJcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcclxuICAgIGlzUmVqZWN0ZWQ6IGJvb2xlYW47IC8vIOqxsOygiOuQnCDtmozsm5DqsIDsnoUg7Iug7LKtIOyXrOu2gFxyXG4gICAgZmFpbGVkTG9naW5BdHRlbXB0czogbnVtYmVyO1xyXG4gICAgaXNMb2NrZWQ6IGJvb2xlYW47XHJcbiAgICBtdXN0Q2hhbmdlUGFzc3dvcmQ/OiBib29sZWFuOyAvLyDsgqzsmqnsnpDqsIAg64uk7J2MIOuhnOq3uOyduCDsi5wg67mE67CA67KI7Zi466W8IOuzgOqyve2VtOyVvCDtlZjripTsp4Ag7Jes67aAXHJcbn1cclxuXHJcbi8vIOy0iOq4sCDsgqzsmqnsnpAg642w7J207YSwICjruYTrsIDrsojtmLjripQg7JWxIOyLnOyekSDsi5wg7ZW07Iux65Cp64uI64ukKVxyXG5jb25zdCBpbml0aWFsVXNlcnNEYXRhOiAoUGFydGlhbDxVc2VyPiAmIHsgaWQ6IHN0cmluZzsgcGFzc3dvcmQ/OiBzdHJpbmcsIHJvbGU6ICd1c2VyJyB8ICdhZG1pbicgfSlbXSA9IFtcclxuICAgIHtcclxuICAgICAgICBpZDogJ2FkbWluJyxcclxuICAgICAgICBwYXNzd29yZDogJ2FkbWluJyxcclxuICAgICAgICBuYW1lOiAn6rSA66as7J6QJyxcclxuICAgICAgICBlbWFpbDogJ2FkbWluQGV4YW1wbGUuY29tJyxcclxuICAgICAgICBwaG9uZTogJzAxMC0wMDAwLTAwMDAnLFxyXG4gICAgICAgIGFkZHJlc3M6ICfshJzsmrjtirnrs4Tsi5wg6rCV64Ko6rWsJyxcclxuICAgICAgICBhZGRyZXNzRGV0YWlsOiAn7YWM7Zek656A66GcIDEyMycsXHJcbiAgICAgICAgemlwQ29kZTogJzA2MTIzJyxcclxuICAgICAgICByb2xlOiAnYWRtaW4nLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDEtMDEnLFxyXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIGlzUmVqZWN0ZWQ6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBpZDogJ2FhYScsXHJcbiAgICAgICAgcGFzc3dvcmQ6ICdhYWEnLFxyXG4gICAgICAgIG5hbWU6ICfquYDssqDsiJgnLFxyXG4gICAgICAgIGVtYWlsOiAnYWFhQGV4YW1wbGUuY29tJyxcclxuICAgICAgICBwaG9uZTogJzAxMC0xMTExLTExMTEnLFxyXG4gICAgICAgIGFkZHJlc3M6ICfshJzsmrjtirnrs4Tsi5wg7ISc7LSI6rWsJyxcclxuICAgICAgICBhZGRyZXNzRGV0YWlsOiAn6rCV64Ko64yA66GcIDQ1NicsXHJcbiAgICAgICAgemlwQ29kZTogJzA2NjExJyxcclxuICAgICAgICByb2xlOiAndXNlcicsXHJcbiAgICAgICAgY3JlYXRlZEF0OiAnMjAyNC0wMS0xNScsXHJcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGlkOiAnYmJiJyxcclxuICAgICAgICBwYXNzd29yZDogJ2JiYicsXHJcbiAgICAgICAgbmFtZTogJ+ydtOyYge2drCcsXHJcbiAgICAgICAgZW1haWw6ICdiYmJAZXhhbXBsZS5jb20nLFxyXG4gICAgICAgIHBob25lOiAnMDEwLTIyMjItMjIyMicsXHJcbiAgICAgICAgYWRkcmVzczogJ+yEnOyauO2KueuzhOyLnCDrp4jtj6zqtawnLFxyXG4gICAgICAgIGFkZHJlc3NEZXRhaWw6ICftmY3rjIDroZwgNzg5JyxcclxuICAgICAgICB6aXBDb2RlOiAnMDQwMzknLFxyXG4gICAgICAgIHJvbGU6ICd1c2VyJyxcclxuICAgICAgICBjcmVhdGVkQXQ6ICcyMDI0LTAxLTIwJyxcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgaWQ6ICdjY2MnLFxyXG4gICAgICAgIHBhc3N3b3JkOiAnY2NjJyxcclxuICAgICAgICBuYW1lOiAn7JSo7JSo7JSoJyxcclxuICAgICAgICBlbWFpbDogJ2NjY0BleGFtcGxlLmNvbScsXHJcbiAgICAgICAgcGhvbmU6ICcwMTAtMzMzMy0zMzMzJyxcclxuICAgICAgICBhZGRyZXNzOiAn7KO87IaMIOuvuOyeheugpScsXHJcbiAgICAgICAgcm9sZTogJ3VzZXInLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogJzIwMjQtMDUtMjUnLFxyXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZSwgLy8g7ZqM7JuQ6rCA7J6FIOyKueyduCDrjIDquLBcclxuICAgIH1cclxuXTtcclxuXHJcbi8vIOuhnOy7rCDsiqTthqDrpqzsp4Ag7YKkXHJcbmNvbnN0IFVTRVJTX1NUT1JBR0VfS0VZID0gJ21pbmlfc3RvcmVfdXNlcnMnO1xyXG5jb25zdCBDVVJSRU5UX1VTRVJfS0VZID0gJ21pbmlfc3RvcmVfY3VycmVudF91c2VyJztcclxuY29uc3QgVVNFUlNfVkVSU0lPTl9LRVkgPSAnbWluaV9zdG9yZV91c2Vyc192ZXJzaW9uJztcclxuY29uc3QgQ1VSUkVOVF9WRVJTSU9OID0gJzEuMTAnOyAvLyDrjbDsnbTthLAg6rWs7KGwIOuzgOqyvSDsi5wg7J20IOuyhOyghOydhCDsmKzrpr3ri4jri6QuXHJcblxyXG4vLyDrqZTrqqjrpqwg64K0IOyCrOyaqeyekCDsupDsi5xcclxubGV0IHVzZXJzQ2FjaGU6IFVzZXJbXSB8IG51bGwgPSBudWxsO1xyXG5cclxuLy8g7LSI6riwIOyCrOyaqeyekCDrjbDsnbTthLDrpbwg64+Z6riw7KCB7Jy866GcIOyDneyEsSAo7ISc67KEIOyCrOydtOuTnCDrsI8g7LSI6riwIO2BtOudvOydtOyWuO2KuCDroIzrjZTrp4HsmqkpXHJcbi8vIOu5hOuwgOuyiO2YuCDtlbTsi7Hqs7wg6rCZ7J2AIOu5hOuPmeq4sCDsnpHsl4XsnYAg7Y+s7ZWo7ZWY7KeAIOyViuydjFxyXG5jb25zdCBnZXRJbml0aWFsVXNlcnNTeW5jaHJvbm91c2x5ID0gKCk6IFVzZXJbXSA9PiB7XHJcbiAgICByZXR1cm4gaW5pdGlhbFVzZXJzRGF0YS5tYXAodXNlciA9PiAoe1xyXG4gICAgICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgICAgIHBhc3N3b3JkOiB1c2VyLnBhc3N3b3JkIHx8ICcnLCAvLyDstIjquLDsl5DripQg7ZW07Iux65CY7KeAIOyViuydgCDqsJIg65iQ64qUIOu5iCDrrLjsnpDsl7RcclxuICAgICAgICBuYW1lOiB1c2VyLm5hbWUgfHwgJ04vQScsXHJcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwgfHwgJ04vQScsXHJcbiAgICAgICAgcGhvbmU6IHVzZXIucGhvbmUgfHwgJ04vQScsXHJcbiAgICAgICAgYWRkcmVzczogdXNlci5hZGRyZXNzIHx8ICdOL0EnLFxyXG4gICAgICAgIGFkZHJlc3NEZXRhaWw6IHVzZXIuYWRkcmVzc0RldGFpbCB8fCAnJyxcclxuICAgICAgICB6aXBDb2RlOiB1c2VyLnppcENvZGUgfHwgJycsXHJcbiAgICAgICAgcm9sZTogdXNlci5yb2xlLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogdXNlci5jcmVhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgaXNBY3RpdmU6IHVzZXIuaXNBY3RpdmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB1c2VyLmlzQWN0aXZlLFxyXG4gICAgICAgIGlzUmVqZWN0ZWQ6IHVzZXIuaXNSZWplY3RlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB1c2VyLmlzUmVqZWN0ZWQsXHJcbiAgICAgICAgZmFpbGVkTG9naW5BdHRlbXB0czogMCxcclxuICAgICAgICBpc0xvY2tlZDogZmFsc2UsXHJcbiAgICAgICAgbXVzdENoYW5nZVBhc3N3b3JkOiBmYWxzZSxcclxuICAgIH0pKTtcclxufTtcclxuXHJcbi8vIOyCrOyaqeyekCDrjbDsnbTthLAg7LSI6riw7ZmUIO2VqOyImCAo7YG065287J207Ja47Yq4IOyCrOydtOuTnCDruYTrj5nquLApXHJcbmNvbnN0IGluaXRpYWxpemVVc2VycyA9IGFzeW5jICgpOiBQcm9taXNlPFVzZXJbXT4gPT4ge1xyXG4gICAgY29uc3QgaGFzaGVkVXNlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgICBpbml0aWFsVXNlcnNEYXRhLm1hcChhc3luYyAodXNlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9IGF3YWl0IGhhc2hQYXNzd29yZCh1c2VyLnBhc3N3b3JkIHx8ICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiB1c2VyLmlkLFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGhhc2hlZFBhc3N3b3JkLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdXNlci5uYW1lIHx8ICdOL0EnLFxyXG4gICAgICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwgfHwgJ04vQScsXHJcbiAgICAgICAgICAgICAgICBwaG9uZTogdXNlci5waG9uZSB8fCAnTi9BJyxcclxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHVzZXIuYWRkcmVzcyB8fCAnTi9BJyxcclxuICAgICAgICAgICAgICAgIGFkZHJlc3NEZXRhaWw6IHVzZXIuYWRkcmVzc0RldGFpbCB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHppcENvZGU6IHVzZXIuemlwQ29kZSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHJvbGU6IHVzZXIucm9sZSxcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogdXNlci5jcmVhdGVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogdXNlci5pc0FjdGl2ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHVzZXIuaXNBY3RpdmUsXHJcbiAgICAgICAgICAgICAgICBpc1JlamVjdGVkOiB1c2VyLmlzUmVqZWN0ZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdXNlci5pc1JlamVjdGVkLFxyXG4gICAgICAgICAgICAgICAgZmFpbGVkTG9naW5BdHRlbXB0czogMCxcclxuICAgICAgICAgICAgICAgIGlzTG9ja2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG11c3RDaGFuZ2VQYXNzd29yZDogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbiAgICBzYXZlVXNlcnMoaGFzaGVkVXNlcnMpO1xyXG4gICAgcmV0dXJuIGhhc2hlZFVzZXJzO1xyXG59O1xyXG5cclxuLy8g7IKs7Jqp7J6QIOuNsOydtO2EsCDqtIDrpqwg7ZWo7IiY65OkXHJcbmV4cG9ydCBjb25zdCBnZXRVc2VycyA9ICgpOiBVc2VyW10gPT4ge1xyXG4gICAgLy8g7ISc67KEIOyCrOydtOuTnCAoQVBJIOudvOyasO2KuCDrk7EpXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAodXNlcnNDYWNoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlcnNDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g7ISc67KE7JeQ7ISc64qUIO2VreyDgSDrj5nquLDsoIHsnLzroZwg7LSI6riwIOyCrOyaqeyekCDrqqnroZ3snYQg67CY7ZmYXHJcbiAgICAgICAgdXNlcnNDYWNoZSA9IGdldEluaXRpYWxVc2Vyc1N5bmNocm9ub3VzbHkoKTtcclxuICAgICAgICByZXR1cm4gdXNlcnNDYWNoZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDtgbTrnbzsnbTslrjtirgg7IKs7J2065OcXHJcbiAgICBpZiAodXNlcnNDYWNoZSkge1xyXG4gICAgICAgIHJldHVybiB1c2Vyc0NhY2hlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0b3JlZFZlcnNpb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShVU0VSU19WRVJTSU9OX0tFWSk7XHJcbiAgICBjb25zdCBzdG9yZWRVc2VycyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFVTRVJTX1NUT1JBR0VfS0VZKTtcclxuXHJcbiAgICBpZiAoIXN0b3JlZFVzZXJzIHx8IHN0b3JlZFZlcnNpb24gIT09IENVUlJFTlRfVkVSU0lPTikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIHVzZXIgZGF0YSBpbiBsb2NhbFN0b3JhZ2UuXCIpO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxVc2VycyA9IGdldEluaXRpYWxVc2Vyc1N5bmNocm9ub3VzbHkoKTtcclxuICAgICAgICB1c2Vyc0NhY2hlID0gaW5pdGlhbFVzZXJzOyAvLyDrqLzsoIAg64+Z6riwIOuNsOydtO2EsOuhnCDsupDsi5wg7LGE7Jqw6riwXHJcblxyXG4gICAgICAgIC8vIOuwseq3uOudvOyatOuTnOyXkOyEnCDruYTrj5nquLAg7ZW07IuxIOuwjyDsoIDsnqVcclxuICAgICAgICBpbml0aWFsaXplVXNlcnMoKS50aGVuKGhhc2hlZFVzZXJzID0+IHtcclxuICAgICAgICAgICAgdXNlcnNDYWNoZSA9IGhhc2hlZFVzZXJzOyAvLyDtlbTsi7HrkJwg642w7J207YSw66GcIOy6kOyLnCDsl4XrjbDsnbTtirhcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaW5pdGlhbFVzZXJzOyAvLyDrj5nquLDsoIHsnLzroZwg7LSI6riwIOuNsOydtO2EsCDsmrDshKAg67CY7ZmYXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkVXNlcnM6IFVzZXJbXSA9IEpTT04ucGFyc2Uoc3RvcmVkVXNlcnMpO1xyXG4gICAgICAgIHVzZXJzQ2FjaGUgPSBwYXJzZWRVc2VycztcclxuICAgICAgICByZXR1cm4gcGFyc2VkVXNlcnM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLroZzsu6wg7Iqk7Yag66as7KeA7JeQ7IScIOyCrOyaqeyekCDsoJXrs7Trpbwg7YyM7Iux7ZWY64qUIOuNsCDsi6TtjKjtlojsirXri4jri6QuXCIsIGVycm9yKTtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShVU0VSU19TVE9SQUdFX0tFWSk7XHJcbiAgICAgICAgLy8g67mE64+Z6riwIOy0iOq4sO2ZlCDsi6TtlolcclxuICAgICAgICBpbml0aWFsaXplVXNlcnMoKS50aGVuKGhhc2hlZFVzZXJzID0+IHtcclxuICAgICAgICAgICAgdXNlcnNDYWNoZSA9IGhhc2hlZFVzZXJzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOydvOuLqCDruYgg67Cw7Je0IOuwmO2ZmCwgVUnripQgQ29udGV4dOyXkCDrlLDrnbwg66as66CM642U66eBIOuQoCDqsoNcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2F2ZVVzZXJzID0gKHVzZXJzOiBVc2VyW10pID0+IHtcclxuICAgIC8vIOuplOuqqOumrCDsupDsi5wg7JeF642w7J207Yq4XHJcbiAgICB1c2Vyc0NhY2hlID0gdXNlcnM7XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKTtcclxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFVTRVJTX1ZFUlNJT05fS0VZLCBDVVJSRU5UX1ZFUlNJT04pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkZFVzZXIgPSBhc3luYyAodXNlckRhdGE6IE9taXQ8VXNlciwgJ2NyZWF0ZWRBdCcgfCAnZmFpbGVkTG9naW5BdHRlbXB0cycgfCAnaXNMb2NrZWQnIHwgJ211c3RDaGFuZ2VQYXNzd29yZCc+KSA9PiB7XHJcbiAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XHJcblxyXG4gICAgaWYgKHVzZXJzLnNvbWUodSA9PiB1LmlkID09PSB1c2VyRGF0YS5pZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+ydtOuvuCDsobTsnqztlZjripQgSUTsnoXri4jri6QuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSBhd2FpdCBoYXNoUGFzc3dvcmQodXNlckRhdGEucGFzc3dvcmQpO1xyXG5cclxuICAgIGNvbnN0IG5ld1VzZXI6IFVzZXIgPSB7XHJcbiAgICAgICAgLi4udXNlckRhdGEsXHJcbiAgICAgICAgcGFzc3dvcmQ6IGhhc2hlZFBhc3N3b3JkLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgICAgZmFpbGVkTG9naW5BdHRlbXB0czogMCxcclxuICAgICAgICBpc0xvY2tlZDogZmFsc2UsXHJcbiAgICAgICAgbXVzdENoYW5nZVBhc3N3b3JkOiBmYWxzZSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZFVzZXJzID0gWy4uLnVzZXJzLCBuZXdVc2VyXTtcclxuICAgIHNhdmVVc2Vycyh1cGRhdGVkVXNlcnMpO1xyXG4gICAgcmV0dXJuIG5ld1VzZXI7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlciA9IGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFVzZXI+KSA9PiB7XHJcbiAgICBsZXQgdXNlcnMgPSBnZXRVc2VycygpO1xyXG4gICAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gaWQpO1xyXG5cclxuICAgIGlmICh1c2VySW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCfsgqzsmqnsnpDrpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZFVzZXIgPSB7IC4uLnVzZXJzW3VzZXJJbmRleF0sIC4uLnVwZGF0ZXMgfTtcclxuXHJcbiAgICBpZiAodXBkYXRlcy5wYXNzd29yZCAmJiB1cGRhdGVzLnBhc3N3b3JkICE9PSB1c2Vyc1t1c2VySW5kZXhdLnBhc3N3b3JkKSB7XHJcbiAgICAgICAgdXBkYXRlZFVzZXIucGFzc3dvcmQgPSBhd2FpdCBoYXNoUGFzc3dvcmQodXBkYXRlcy5wYXNzd29yZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXBkYXRlZFVzZXJzID0gWy4uLnVzZXJzXTtcclxuICAgIHVwZGF0ZWRVc2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXI7XHJcbiAgICBcclxuICAgIHNhdmVVc2Vycyh1cGRhdGVkVXNlcnMpO1xyXG4gICAgcmV0dXJuIHVwZGF0ZWRVc2VyO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlbGV0ZVVzZXIgPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgdXNlcnMgPSBnZXRVc2VycygpO1xyXG4gICAgY29uc3QgZmlsdGVyZWRVc2VycyA9IHVzZXJzLmZpbHRlcih1ID0+IHUuaWQgIT09IGlkKTtcclxuICAgIHNhdmVVc2VycyhmaWx0ZXJlZFVzZXJzKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2dpblVzZXIgPSBhc3luYyAoaWQ6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmc7IHVzZXI/OiBVc2VyIHwgbnVsbCB9PiA9PiB7XHJcbiAgICBjb25zdCB1c2VycyA9IGdldFVzZXJzKCk7XHJcbiAgICBjb25zdCB1c2VyID0gdXNlcnMuZmluZCh1ID0+IHUuaWQgPT09IGlkKTtcclxuICAgIFxyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdJRCDrmJDripQg67mE67CA67KI7Zi46rCAIOyYrOuwlOultOyngCDslYrsirXri4jri6QuJyB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIXVzZXIuaXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ+u5hO2ZnOyEse2ZlOuQnCDqs4TsoJXsnoXri4jri6QuJyB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VyLmlzTG9ja2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICfqs4TsoJXsnbQg7J6g6rK87Iq164uI64ukLiDqtIDrpqzsnpDsl5Dqsowg66y47J2Y7ZWY7IS47JqULicgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGdldFNlY3VyaXR5U2V0dGluZ3MoKTtcclxuICAgIGNvbnN0IGlzVmFsaWRQYXNzd29yZCA9IGF3YWl0IHZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkLCB1c2VyLnBhc3N3b3JkKTtcclxuXHJcbiAgICBpZiAoaXNWYWxpZFBhc3N3b3JkKSB7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFVzZXIgPSB7IC4uLnVzZXIsIGZhaWxlZExvZ2luQXR0ZW1wdHM6IDAgfTtcclxuICAgICAgICBhd2FpdCB1cGRhdGVVc2VyKGlkLCB7IGZhaWxlZExvZ2luQXR0ZW1wdHM6IDAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ+uhnOq3uOyduCDshLHqs7UnLCB1c2VyOiB1cGRhdGVkVXNlciB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBuZXdBdHRlbXB0cyA9IHVzZXIuZmFpbGVkTG9naW5BdHRlbXB0cyArIDE7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgSUQg65iQ64qUIOu5hOuwgOuyiO2YuOqwgCDsmKzrsJTrpbTsp4Ag7JWK7Iq164uI64ukLiAo64Ko7J2AIOyLnOuPhDogJHtzZXR0aW5ncy5tYXhMb2dpbkF0dGVtcHRzIC0gbmV3QXR0ZW1wdHN97ZqMKWA7XHJcbiAgICAgICAgbGV0IGlzTG9ja2VkOiBib29sZWFuID0gdXNlci5pc0xvY2tlZDtcclxuXHJcbiAgICAgICAgaWYgKG5ld0F0dGVtcHRzID49IHNldHRpbmdzLm1heExvZ2luQXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgaXNMb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gYOuhnOq3uOyduCDsi5zrj4Qg7Zqf7IiY66W8IOy0iOqzvO2VmOyXrCDqs4TsoJXsnbQg7J6g6rK87Iq164uI64ukLiAoJHtzZXR0aW5ncy5tYXhMb2dpbkF0dGVtcHRzfe2ajCDstIjqs7wpYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXdhaXQgdXBkYXRlVXNlcihpZCwgeyBmYWlsZWRMb2dpbkF0dGVtcHRzOiBuZXdBdHRlbXB0cywgaXNMb2NrZWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6IG1lc3NhZ2UgfTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50VXNlciA9ICgpOiBVc2VyIHwgbnVsbCA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShDVVJSRU5UX1VTRVJfS0VZKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IG51bGw7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRDdXJyZW50VXNlciA9ICh1c2VyOiBVc2VyIHwgbnVsbCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcbiAgICBcclxuICAgIGlmICh1c2VyKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQ1VSUkVOVF9VU0VSX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShDVVJSRU5UX1VTRVJfS0VZKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsb2dvdXRVc2VyID0gKCkgPT4ge1xyXG4gICAgc2V0Q3VycmVudFVzZXIobnVsbCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVVc2VySWQgPSAoaWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gICAgaWYgKGlkLmxlbmd0aCA8IDQpIHJldHVybiAnSUTripQgNOyekCDsnbTsg4HsnbTslrTslbwg7ZWp64uI64ukLic7XHJcbiAgICBpZiAoaWQubGVuZ3RoID4gMjApIHJldHVybiAnSUTripQgMjDsnpAg7J207ZWY7Jes7JW8IO2VqeuLiOuLpC4nO1xyXG4gICAgaWYgKCEvXlthLXpBLVowLTlfXSskLy50ZXN0KGlkKSkgcmV0dXJuICdJROuKlCDsmIHrrLgsIOyIq+yekCwg7Ja4642U7Iqk7L2U7Ja066eMIOyCrOyaqSDqsIDriqXtlanri4jri6QuJztcclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlUGFzc3dvcmQgPSAocGFzc3dvcmQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xyXG4gICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IDQpIHJldHVybiAn67mE67CA67KI7Zi464qUIDTsnpAg7J207IOB7J207Ja07JW8IO2VqeuLiOuLpC4nO1xyXG4gICAgLy8g7KCV6rec7IudOiDstZzshowgOOyekCwg7ZWY64KYIOydtOyDgeydmCDrrLjsnpAsIO2VmOuCmOydmCDsiKvsnpAg67CPIO2VmOuCmOydmCDtirnsiJgg66y47J6QXHJcbiAgICAvLyBpZiAoIS9eKD89LipbQS1aYS16XSkoPz0uKlxcZCkoPz0uKltAJCElKiM/Jl0pW0EtWmEtelxcZEAkISUqIz8mXXs4LH0kLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgLy8gICAgIHJldHVybiAn67mE67CA67KI7Zi464qUIOy1nOyGjCA47J6QLCDtlZjrgpgg7J207IOB7J2YIOusuOyekCwg7Iir7J6QLCDtirnsiJjrrLjsnpDrpbwg7Y+s7ZWo7ZW07JW8IO2VqeuLiOuLpC4nO1xyXG4gICAgLy8gfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVFbWFpbCA9IChlbWFpbDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgICBpZiAoIS9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QoZW1haWwpKSByZXR1cm4gJ+ycoO2aqO2VmOyngCDslYrsnYAg7J2066mU7J28IOyjvOyGjOyeheuLiOuLpC4nO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVQaG9uZSA9IChwaG9uZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgICBpZiAoIS9eXFxkezN9LVxcZHszLDR9LVxcZHs0fSQvLnRlc3QocGhvbmUpKSByZXR1cm4gJ+ycoO2aqO2VmOyngCDslYrsnYAg7KCE7ZmU67KI7Zi4IO2YleyLneyeheuLiOuLpC4gKOyYiDogMDEwLTEyMzQtNTY3OCknO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07ICJdLCJuYW1lcyI6WyJoYXNoUGFzc3dvcmQiLCJ2ZXJpZnlQYXNzd29yZCIsImdldFNlY3VyaXR5U2V0dGluZ3MiLCJpbml0aWFsVXNlcnNEYXRhIiwiaWQiLCJwYXNzd29yZCIsIm5hbWUiLCJlbWFpbCIsInBob25lIiwiYWRkcmVzcyIsImFkZHJlc3NEZXRhaWwiLCJ6aXBDb2RlIiwicm9sZSIsImNyZWF0ZWRBdCIsImlzQWN0aXZlIiwiaXNSZWplY3RlZCIsIlVTRVJTX1NUT1JBR0VfS0VZIiwiQ1VSUkVOVF9VU0VSX0tFWSIsIlVTRVJTX1ZFUlNJT05fS0VZIiwiQ1VSUkVOVF9WRVJTSU9OIiwidXNlcnNDYWNoZSIsImdldEluaXRpYWxVc2Vyc1N5bmNocm9ub3VzbHkiLCJtYXAiLCJ1c2VyIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ1bmRlZmluZWQiLCJmYWlsZWRMb2dpbkF0dGVtcHRzIiwiaXNMb2NrZWQiLCJtdXN0Q2hhbmdlUGFzc3dvcmQiLCJpbml0aWFsaXplVXNlcnMiLCJoYXNoZWRVc2VycyIsIlByb21pc2UiLCJhbGwiLCJoYXNoZWRQYXNzd29yZCIsInNhdmVVc2VycyIsImdldFVzZXJzIiwic3RvcmVkVmVyc2lvbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzdG9yZWRVc2VycyIsImNvbnNvbGUiLCJsb2ciLCJpbml0aWFsVXNlcnMiLCJ0aGVuIiwicGFyc2VkVXNlcnMiLCJKU09OIiwicGFyc2UiLCJlcnJvciIsInJlbW92ZUl0ZW0iLCJ1c2VycyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJhZGRVc2VyIiwidXNlckRhdGEiLCJzb21lIiwidSIsIkVycm9yIiwibmV3VXNlciIsInVwZGF0ZWRVc2VycyIsInVwZGF0ZVVzZXIiLCJ1cGRhdGVzIiwidXNlckluZGV4IiwiZmluZEluZGV4IiwidXBkYXRlZFVzZXIiLCJkZWxldGVVc2VyIiwiZmlsdGVyZWRVc2VycyIsImZpbHRlciIsImxvZ2luVXNlciIsImZpbmQiLCJzdWNjZXNzIiwibWVzc2FnZSIsInNldHRpbmdzIiwiaXNWYWxpZFBhc3N3b3JkIiwibmV3QXR0ZW1wdHMiLCJtYXhMb2dpbkF0dGVtcHRzIiwiZ2V0Q3VycmVudFVzZXIiLCJzdG9yZWQiLCJzZXRDdXJyZW50VXNlciIsImxvZ291dFVzZXIiLCJ2YWxpZGF0ZVVzZXJJZCIsImxlbmd0aCIsInRlc3QiLCJ2YWxpZGF0ZVBhc3N3b3JkIiwidmFsaWRhdGVFbWFpbCIsInZhbGlkYXRlUGhvbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/users.ts\n"));

/***/ })

});